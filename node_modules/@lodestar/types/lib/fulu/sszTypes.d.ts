import { ByteVectorType, ContainerType, ListBasicType, ListCompositeType, VectorBasicType, VectorCompositeType } from "@chainsafe/ssz";
export declare const Metadata: ContainerType<{
    custodyGroupCount: import("@chainsafe/ssz").UintNumberType;
    seqNumber: import("@chainsafe/ssz").UintBigintType;
    attnets: import("@chainsafe/ssz").BitVectorType;
    syncnets: import("@chainsafe/ssz").BitVectorType;
}>;
export declare const Cell: ByteVectorType;
export declare const DataColumn: ListCompositeType<ByteVectorType>;
export declare const ExtendedMatrix: ListCompositeType<ByteVectorType>;
export declare const KzgCommitmentsInclusionProof: VectorCompositeType<ByteVectorType>;
export declare const ProposerLookahead: VectorBasicType<import("@chainsafe/ssz").UintNumberType>;
export declare const DataColumnSidecar: ContainerType<{
    index: import("@chainsafe/ssz").UintNumberType;
    column: ListCompositeType<ByteVectorType>;
    kzgCommitments: ListCompositeType<ByteVectorType>;
    kzgProofs: ListCompositeType<ByteVectorType>;
    signedBlockHeader: ContainerType<{
        message: ContainerType<{
            slot: import("@chainsafe/ssz").UintNumberType;
            proposerIndex: import("@chainsafe/ssz").UintNumberType;
            parentRoot: ByteVectorType;
            stateRoot: ByteVectorType;
            bodyRoot: ByteVectorType;
        }>;
        signature: ByteVectorType;
    }>;
    kzgCommitmentsInclusionProof: VectorCompositeType<ByteVectorType>;
}>;
export declare const DataColumnSidecars: ListCompositeType<ContainerType<{
    index: import("@chainsafe/ssz").UintNumberType;
    column: ListCompositeType<ByteVectorType>;
    kzgCommitments: ListCompositeType<ByteVectorType>;
    kzgProofs: ListCompositeType<ByteVectorType>;
    signedBlockHeader: ContainerType<{
        message: ContainerType<{
            slot: import("@chainsafe/ssz").UintNumberType;
            proposerIndex: import("@chainsafe/ssz").UintNumberType;
            parentRoot: ByteVectorType;
            stateRoot: ByteVectorType;
            bodyRoot: ByteVectorType;
        }>;
        signature: ByteVectorType;
    }>;
    kzgCommitmentsInclusionProof: VectorCompositeType<ByteVectorType>;
}>>;
export declare const MatrixEntry: ContainerType<{
    cell: ByteVectorType;
    kzgProof: ByteVectorType;
    columnIndex: import("@chainsafe/ssz").UintNumberType;
    rowIndex: import("@chainsafe/ssz").UintNumberType;
}>;
export declare const DataColumnIdentifier: ContainerType<{
    blockRoot: ByteVectorType;
    index: import("@chainsafe/ssz").UintNumberType;
}>;
export declare const DataColumnSidecarsByRootRequest: ListCompositeType<ContainerType<{
    blockRoot: ByteVectorType;
    index: import("@chainsafe/ssz").UintNumberType;
}>>;
export declare const DataColumnSidecarsByRangeRequest: ContainerType<{
    startSlot: import("@chainsafe/ssz").UintNumberType;
    count: import("@chainsafe/ssz").UintNumberType;
    columns: ListBasicType<import("@chainsafe/ssz").UintNumberType>;
}>;
export declare const BeaconState: ContainerType<{
    proposerLookahead: VectorBasicType<import("@chainsafe/ssz").UintNumberType>;
    genesisTime: import("@chainsafe/ssz").UintNumberType;
    genesisValidatorsRoot: ByteVectorType;
    slot: import("@chainsafe/ssz").UintNumberType;
    fork: ContainerType<{
        previousVersion: ByteVectorType;
        currentVersion: ByteVectorType;
        epoch: import("@chainsafe/ssz").UintNumberType;
    }>;
    latestBlockHeader: ContainerType<{
        slot: import("@chainsafe/ssz").UintNumberType;
        proposerIndex: import("@chainsafe/ssz").UintNumberType;
        parentRoot: ByteVectorType;
        stateRoot: ByteVectorType;
        bodyRoot: ByteVectorType;
    }>;
    blockRoots: VectorCompositeType<ByteVectorType>;
    stateRoots: VectorCompositeType<ByteVectorType>;
    historicalRoots: ListCompositeType<ByteVectorType>;
    eth1Data: ContainerType<{
        depositRoot: ByteVectorType;
        depositCount: import("@chainsafe/ssz").UintNumberType;
        blockHash: ByteVectorType;
    }>;
    eth1DataVotes: ListCompositeType<ContainerType<{
        depositRoot: ByteVectorType;
        depositCount: import("@chainsafe/ssz").UintNumberType;
        blockHash: ByteVectorType;
    }>>;
    eth1DepositIndex: import("@chainsafe/ssz").UintNumberType;
    validators: ListCompositeType<import("../phase0/validator.js").ValidatorNodeStructType>;
    balances: import("@chainsafe/ssz").ListUintNum64Type;
    randaoMixes: VectorCompositeType<ByteVectorType>;
    slashings: VectorBasicType<import("@chainsafe/ssz").UintNumberType>;
    previousEpochParticipation: ListBasicType<import("@chainsafe/ssz").UintNumberType>;
    currentEpochParticipation: ListBasicType<import("@chainsafe/ssz").UintNumberType>;
    justificationBits: import("@chainsafe/ssz").BitVectorType;
    previousJustifiedCheckpoint: ContainerType<{
        epoch: import("@chainsafe/ssz").UintNumberType;
        root: ByteVectorType;
    }>;
    currentJustifiedCheckpoint: ContainerType<{
        epoch: import("@chainsafe/ssz").UintNumberType;
        root: ByteVectorType;
    }>;
    finalizedCheckpoint: ContainerType<{
        epoch: import("@chainsafe/ssz").UintNumberType;
        root: ByteVectorType;
    }>;
    inactivityScores: ListBasicType<import("@chainsafe/ssz").UintNumberType>;
    currentSyncCommittee: ContainerType<{
        pubkeys: VectorCompositeType<ByteVectorType>;
        aggregatePubkey: ByteVectorType;
    }>;
    nextSyncCommittee: ContainerType<{
        pubkeys: VectorCompositeType<ByteVectorType>;
        aggregatePubkey: ByteVectorType;
    }>;
    latestExecutionPayloadHeader: ContainerType<{
        blobGasUsed: import("@chainsafe/ssz").UintBigintType;
        excessBlobGas: import("@chainsafe/ssz").UintBigintType;
        withdrawalsRoot: ByteVectorType;
        transactionsRoot: ByteVectorType;
        parentHash: ByteVectorType;
        feeRecipient: import("../utils/executionAddress.js").ExecutionAddressType;
        stateRoot: ByteVectorType;
        receiptsRoot: ByteVectorType;
        logsBloom: ByteVectorType;
        prevRandao: ByteVectorType;
        blockNumber: import("@chainsafe/ssz").UintNumberType;
        gasLimit: import("@chainsafe/ssz").UintNumberType;
        gasUsed: import("@chainsafe/ssz").UintNumberType;
        timestamp: import("@chainsafe/ssz").UintNumberType;
        extraData: import("@chainsafe/ssz").ByteListType;
        baseFeePerGas: import("@chainsafe/ssz").UintBigintType;
        blockHash: ByteVectorType;
    }>;
    nextWithdrawalIndex: import("@chainsafe/ssz").UintNumberType;
    nextWithdrawalValidatorIndex: import("@chainsafe/ssz").UintNumberType;
    historicalSummaries: ListCompositeType<ContainerType<{
        blockSummaryRoot: ByteVectorType;
        stateSummaryRoot: ByteVectorType;
    }>>;
    depositRequestsStartIndex: import("@chainsafe/ssz").UintBigintType;
    depositBalanceToConsume: import("@chainsafe/ssz").UintBigintType;
    exitBalanceToConsume: import("@chainsafe/ssz").UintBigintType;
    earliestExitEpoch: import("@chainsafe/ssz").UintNumberType;
    consolidationBalanceToConsume: import("@chainsafe/ssz").UintBigintType;
    earliestConsolidationEpoch: import("@chainsafe/ssz").UintNumberType;
    pendingDeposits: ListCompositeType<ContainerType<{
        pubkey: ByteVectorType;
        withdrawalCredentials: ByteVectorType;
        amount: import("@chainsafe/ssz").UintNumberType;
        signature: ByteVectorType;
        slot: import("@chainsafe/ssz").UintNumberType;
    }>>;
    pendingPartialWithdrawals: ListCompositeType<ContainerType<{
        validatorIndex: import("@chainsafe/ssz").UintNumberType;
        amount: import("@chainsafe/ssz").UintBigintType;
        withdrawableEpoch: import("@chainsafe/ssz").UintNumberType;
    }>>;
    pendingConsolidations: ListCompositeType<ContainerType<{
        sourceIndex: import("@chainsafe/ssz").UintNumberType;
        targetIndex: import("@chainsafe/ssz").UintNumberType;
    }>>;
}>;
//# sourceMappingURL=sszTypes.d.ts.map